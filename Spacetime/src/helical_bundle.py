"""Helical bundle construction utilities.

This module assembles idealized alpha helices into a symmetric bundle.
The geometry mirrors a bundle of coiled springs wrapping around a core,
maintaining the radius and rise invariants akin to the Preservation
Constraint Equation's conservation of structure.
"""

from __future__ import annotations

from math import cos, sin, radians
from typing import Iterable, List, Sequence, Tuple

# Type aliases for clarity
Chain = Tuple[str, str]
Atom = Tuple[str, int, str, Tuple[float, float, float]]


def ideal_alpha_helix(
    sequence: str,
    *,
    radius: float = 2.3,
    rise: float = 1.5,
    angle_deg: float = 100.0,
    origin: Tuple[float, float, float] = (0.0, 0.0, 0.0),
    phase: float = 0.0,
) -> List[Atom]:
    """Return backbone coordinates for an ideal alpha helix.

    The helix is parameterized much like winding a watch spring: each
    residue advances by a fixed axial rise and rotates around the
    cylinder's radius.  These invariants mimic the way a PCE solution
    preserves its amplitude and phase.

    Parameters
    ----------
    sequence:
        Amino-acid sequence of the helix.
    radius:
        Radial distance from the helix center to Cα atoms, in Å.
    rise:
        Axial displacement per residue along the helix, in Å.
    angle_deg:
        Rotation per residue in degrees.
    origin:
        Cartesian origin of the helix base.
    phase:
        Initial angular offset in radians.

    Returns
    -------
    list of Atom tuples
        Each tuple contains (chain_id, residue_index, residue_code,
        (x, y, z)).  The chain identifier is empty because helix
        assembly determines it later.
    """

    ox, oy, oz = origin
    angle = radians(angle_deg)

    atoms: List[Atom] = []
    for i, aa in enumerate(sequence, start=1):
        theta = phase + (i - 1) * angle
        x = ox + radius * cos(theta)
        y = oy + radius * sin(theta)
        z = oz + (i - 1) * rise
        atoms.append(("", i, aa, (x, y, z)))
    return atoms


def assemble_four_helix_bundle(bundle: Sequence[Chain]) -> List[Atom]:
    """Create a four-helix bundle from input sequences.

    Each helix is positioned like a spoke in a wheel, rotated by 90°
    increments and shifted so that their collective center remains at
    the origin.  This mirrors four balanced forces preserving a common
    equilibrium—the mechanical analogue of the PCE's constraint.
    """

    # Geometry: (x0, y0, phase)
    geometry = {
        "A": (8.0, 0.0, 0.0),
        "B": (-8.0, 0.0, radians(60.0)),
        "C": (0.0, 8.0, radians(120.0)),
        "D": (0.0, -8.0, radians(180.0)),
    }

    atoms: List[Atom] = []
    for chain_id, seq in bundle:
        x0, y0, phase = geometry[chain_id]
        helix = ideal_alpha_helix(seq, origin=(x0, y0, 0.0), phase=phase)
        atoms.extend([(chain_id, resi, aa, coord) for _, resi, aa, coord in helix])
    return atoms


def write_ca_pdb(atoms: Iterable[Atom], filename: str, start_serial: int = 1) -> None:
    """Write Cα-only PDB for the provided atoms.

    The output is a minimalist model akin to a wireframe sculpture—
    enough to illustrate the geometry while avoiding unnecessary mass.
    """

    res_map = {
        "A": "ALA",
        "R": "ARG",
        "N": "ASN",
        "D": "ASP",
        "C": "CYS",
        "Q": "GLN",
        "E": "GLU",
        "G": "GLY",
        "H": "HIS",
        "I": "ILE",
        "L": "LEU",
        "K": "LYS",
        "M": "MET",
        "F": "PHE",
        "P": "PRO",
        "S": "SER",
        "T": "THR",
        "W": "TRP",
        "Y": "TYR",
        "V": "VAL",
        "U": "SEC",
        "O": "PYL",
        "X": "GLY",
    }

    serial = start_serial
    with open(filename, "w", encoding="utf-8") as handle:
        handle.write("REMARK  Generated by helical_bundle\n")
        for chain, resi, aa, (x, y, z) in atoms:
            resn = res_map.get(aa, "GLY")
            handle.write(
                f"ATOM  {serial:5d}  CA  {resn} {chain}{resi:4d}    "
                f"{x:8.3f}{y:8.3f}{z:8.3f}  1.00 20.00           C\n"
            )
            serial += 1


def write_multichain_fasta(chains: Sequence[Chain], filename: str) -> None:
    """Write an AlphaFold-Multimer compatible FASTA file.

    The FASTA acts like a score sheet for a quartet: each chain's
    sequence occupies its own movement, ensuring algorithms can harmonize
    them correctly.
    """

    with open(filename, "w", encoding="utf-8") as handle:
        for chain_id, seq in chains:
            handle.write(f">{chain_id}\n{seq}\n")
